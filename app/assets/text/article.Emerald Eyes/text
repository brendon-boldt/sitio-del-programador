Emerald Eyes was my _magnum opus_ of my high school programming career; in short, it is a remote console server and client application pair written in C++ (mostly C, actually) using BSD sockets. The server is simply a console program that consists a short set up on one computer (i.e., specifying a password and forwarding a port) and can allow the client to use the terminal on the server. The client also made use of command line interface using using a combination of native commands shell commands (command prompt vs. bash) and custom file transfer commands (namely uploading and downloading). While this is mostly just an SSH clone--sans the “secure”--it was quite fun and the perfect project at the time.

I began the project near the beginning of my junior year as a way to test and improve my rather nascent knowledge of C++ and C (I had been self-teaching the language for less than a year at that point). I had no knowledge of networking (past connecting to Wi-Fi) either high-level or low-level, but it seemed interesting and challenging (even in high school my programming mentality was as follows: that seems hard and above my level--I'm going to do it anyway) so I embarked into the ever feared world of C and its sockets.

This is point where I give a mandatory shout-out to [Beej's Guide to Networking](http://beej.us/guide/bgnet/) as it was my primary source; it is complete, well written, full of examples, widely recommended, and generally seems to be for networking in C what Effective Java is to Java. The initial learning curve was quite steep (a lot of overhead, so to speak) as I had to learn the finer details (among the coarser ones) of topics such as IP, TCP, UDP, blocking, polling, and buffering as well as being more comfortable with pointers than my own hands, but I made progress. My biggest sticking point was properly managing the nature of TCP sockets which can be summarized as follows:

> If a TCP socket sends your data, the receiver will receive it. If it tells you “I sent 100 bytes”, it did, and it will be intact on the other side, but there's no guarantee that it will get there in 100 bytes--it may just get there 1 byte at a time if it pleases. Or if you send 100 bytes twice, it could very well get there as 40 bytes, 100 bytes, and then the final 60. Or the kernel just might decide to send nothing at all.

And that's all fine and dandy until you realize you are trying to write 100 bytes of data from a 100 byte buffer that only had 20 bytes of data in it (can you say data corruption?), but I eventually figured it out. Overall, I would keep your default SSH client installed, but the project was well worth the time I spent on it.
